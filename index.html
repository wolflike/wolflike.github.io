<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/thumbup.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/thumbup.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"wolflike.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="没有什么知识是学不会的">
<meta property="og:type" content="website">
<meta property="og:title" content="wolflike">
<meta property="og:url" content="http://wolflike.github.io/index.html">
<meta property="og:site_name" content="wolflike">
<meta property="og:description" content="没有什么知识是学不会的">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="鸿曦">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://wolflike.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>wolflike</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">wolflike</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">写博客并没有浪费我们的时间，而是见证了我们的成长</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">3</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">6</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wolflike.github.io/2021/05/13/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%9B%BE%E7%81%B5.jpg">
      <meta itemprop="name" content="鸿曦">
      <meta itemprop="description" content="没有什么知识是学不会的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wolflike">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">ReentrantLock源码分析</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 12:25:35" itemprop="dateCreated datePublished" datetime="2021-05-13T12:25:35+08:00">2021-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-是什么"><a href="#1-是什么" class="headerlink" title="1.是什么"></a>1.是什么</h3><p>ReentrantLock是Doug Lea 大师写的一个同步线程的组件，也就是我们所谓的锁。这个对象主要是对用户开放两个方法：lock(),unlock()。也即是加锁和解锁。当然他也提供了Condition，在这里暂不做讨论。</p>
<h3 id="2-为什么"><a href="#2-为什么" class="headerlink" title="2.为什么"></a>2.为什么</h3><p>其实Doug Lea大师写的所有同步组件的本质思想是<strong>尽量不调用系统函数</strong>。因为调用系统函数对于高并发场景来说很浪费时间，能在用户态上解决同步问题尽量在用户态上解决。</p>
<h3 id="3-怎么做（源码分析）"><a href="#3-怎么做（源码分析）" class="headerlink" title="3.怎么做（源码分析）"></a>3.怎么做（源码分析）</h3><p>首先如果让我们自己设计同步组件我们应该如何设计？</p>
<h4 id="通过自旋实现一个同步"><a href="#通过自旋实现一个同步" class="headerlink" title="通过自旋实现一个同步"></a>通过自旋实现一个同步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status=<span class="number">0</span>;<span class="comment">//标识---是否有线程在同步块-----是否有线程上锁成功</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//lock</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	status=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> except,<span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">	<span class="comment">//cas操作,修改status成功则返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作，假如一个线程获得锁后要花费Ns处理业务逻辑，那另外一个线程就会白白的花费Ns的cpu资源 解决思路：让得不到锁的线程让出CPU .</p>
<h4 id="yield-自旋实现同步"><a href="#yield-自旋实现同步" class="headerlink" title="yield+自旋实现同步"></a>yield+自旋实现同步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">     yield();<span class="comment">//自己实现</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//lock</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	status=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决自旋锁的性能问题必须让竞争锁失败的线程不空转,而是在获取不到锁的时候能把cpu资源给让出来，yield()方法就能让出cpu资源，当线程竞争锁失败时，会调用yield方法让出cpu。（让出单位cpu时间片，下一个时间片可能还会执行到当前线程。运行—-&gt;就绪）<br>自旋+yield的方式并没有完全解决问题，当系统只有两个线程竞争锁时，yield是有效的。需要注意的是该方法只是当前让出cpu，有可能操作系统下次还是选择运行该线程，比如里面有2000个线程，想想会有什么问题？</p>
<h4 id="sleep-自旋方式实现同步"><a href="#sleep-自旋方式实现同步" class="headerlink" title="sleep+自旋方式实现同步"></a>sleep+自旋方式实现同步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">		sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//lock</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	status=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：sleep的时间为什么是10？怎么控制呢？很多时候就算你是调用者本身其实你也不知道这个时间是多少 。也即是说你不能控制休眠的时间。</p>
<h4 id="park-自旋方式实现同步"><a href="#park-自旋方式实现同步" class="headerlink" title="park+自旋方式实现同步"></a>park+自旋方式实现同步</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> status=<span class="number">0</span>;</span><br><span class="line">Queue parkQueue;<span class="comment">//集合 数组  list</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!compareAndSet(<span class="number">0</span>,<span class="number">1</span>))&#123;</span><br><span class="line">		<span class="comment">//</span></span><br><span class="line">		park();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//lock    10分钟</span></span><br><span class="line">   。。。。。。</span><br><span class="line">   unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">	lock_notify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//将当期线程加入到等待队列</span></span><br><span class="line">	parkQueue.add(currentThread);</span><br><span class="line">	<span class="comment">//将当期线程释放cpu  阻塞</span></span><br><span class="line">	releaseCpu();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_notify</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//得到要唤醒的线程头部线程</span></span><br><span class="line">	Thread t=parkQueue.header();</span><br><span class="line">	<span class="comment">//唤醒等待线程</span></span><br><span class="line">	unpark(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法就比较完美，使用回调思想来解决控制阻塞的时间。让我们看看大师是如何利用这种机制来实现同步的。</p>
<h4 id="ReentrantLock源码分析之上锁过程"><a href="#ReentrantLock源码分析之上锁过程" class="headerlink" title="ReentrantLock源码分析之上锁过程"></a>ReentrantLock源码分析之上锁过程</h4><h4 id="AQS（AbstractQueuedSynchronizer）类的设计主要代码（具体参考源码）"><a href="#AQS（AbstractQueuedSynchronizer）类的设计主要代码（具体参考源码）" class="headerlink" title="AQS（AbstractQueuedSynchronizer）类的设计主要代码（具体参考源码）"></a>AQS（AbstractQueuedSynchronizer）类的设计主要代码（具体参考源码）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head; <span class="comment">//队首</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;<span class="comment">//尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//锁状态，加锁成功则为1，重入+1 解锁则为0</span></span><br></pre></td></tr></table></figure>

<p>AQS当中的队列示意图 :</p>
<p><img src="/2021/05/13/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/SynchronizedQueue.png" alt="同步队列"></p>
<h4 id="Node类的设计"><a href="#Node类的设计" class="headerlink" title="Node类的设计"></a>Node类的设计</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="上锁过程重点"><a href="#上锁过程重点" class="headerlink" title="上锁过程重点"></a>上锁过程重点</h4><p>锁对象：其实就是ReentrantLock的实例对象，下文应用代码第一行中的lock对象就是所谓的锁<br>自由状态：自由状态表示锁对象没有被别的线程持有，计数器为0<br>计数器：再lock对象中有一个字段state用来记录上锁次数，比如lock对象是自由状态则state为0，如果大于零则表示被线程持有了，当然也有重入那么state则&gt;1<br>waitStatus：仅仅是一个状态而已；ws是一个过渡状态，在不同方法里面判断ws的状态做不同的处理，所以ws=0有其存在的必要性<br>tail：队列的队尾 head：队列的对首 ts：第二个给lock加锁的线程 tf：第一个给lock加锁的线程 tc：当前给线程加锁的线程<br>tl：最后一个加锁的线程 tn：随便某个线程<br>当然这些线程有可能重复，比如第一次加锁的时候tf=tc=tl=tn<br>节点：就是上面的Node类的对象，里面封装了线程，所以某种意义上node就等于一个线程</p>
<h4 id="公平锁lock方法的源码分析"><a href="#公平锁lock方法的源码分析" class="headerlink" title="公平锁lock方法的源码分析"></a>公平锁lock方法的源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);<span class="comment">//1------标识加锁成功之后改变的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="非公平锁的looc方法"><a href="#非公平锁的looc方法" class="headerlink" title="非公平锁的looc方法"></a>非公平锁的looc方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">		setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		 acquire(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>下面给出他们的代码执行逻辑的区别图 :</p>
<p><img src="/2021/05/13/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/FairAndNonFair.png" alt="公平锁和非公平锁的区别"></p>
<p>公平锁的上锁是必须判断自己是不是需要排队；而非公平锁是直接进行CAS修改计数器看能不能加锁成功；如果加锁不成功则乖乖排队(调用acquire)；所以不管公平还是不公平；只要进到了AQS队列当中那么他就会排队；一朝排队；永远排队记住这点 </p>
<h4 id="acquire方法方法源码分析（AQS-acquire-1-）"><a href="#acquire方法方法源码分析（AQS-acquire-1-）" class="headerlink" title="acquire方法方法源码分析（AQS#acquire(1)）"></a>acquire方法方法源码分析（AQS#acquire(1)）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//tryAcquire(arg)尝试加锁，如果加锁失败则会调用acquireQueued方法加入队列去排队，如果加锁成功则不会调用</span></span><br><span class="line">    <span class="comment">//acquireQueued方法下文会有解释</span></span><br><span class="line">    <span class="comment">//加入队列之后线程会立马park，等到解锁之后会被unpark，醒来之后判断自己是否被打断了；被打断下次分析</span></span><br><span class="line">    <span class="comment">//为什么需要执行这个方法？下文解释</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>acquire方法首先会调用tryAcquire方法，注意tryAcquire的结果做了取反 </p>
<h4 id="tryAcquire方法源码分析-Fair-tryAcquire"><a href="#tryAcquire方法源码分析-Fair-tryAcquire" class="headerlink" title="tryAcquire方法源码分析(Fair#tryAcquire)"></a>tryAcquire方法源码分析(Fair#tryAcquire)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取lock对象的上锁状态，如果锁是自由状态则=0，如果被上锁则为1，大于1表示重入</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">//没人占用锁---&gt;我要去上锁----1、锁是自由状态</span></span><br><span class="line">        <span class="comment">//hasQueuedPredecessors，判断自己是否需要排队这个方法比较复杂，</span></span><br><span class="line">        <span class="comment">//下面我会单独介绍，如果不需要排队则进行cas尝试加锁，如果加锁成功则把当前线程设置为拥有锁的线程</span></span><br><span class="line">        <span class="comment">//继而返回true</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">//设置当前线程为拥有锁的线程，方面后面判断是不是重入（只需把这个线程拿出来判断是否当前线程即可判断重入）    </span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果C不等于0，而且当前线程不等于拥有锁的线程则不会进else if 直接返回false，加锁失败</span></span><br><span class="line">    <span class="comment">//如果C不等于0，但是当前线程等于拥有锁的线程则表示这是一次重入，那么直接把状态+1表示重入次数+1</span></span><br><span class="line">    <span class="comment">//那么这里也侧面说明了reentrantlock是可以重入的，因为如果是重入也返回true，也能lock成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="tryAcquire方法源码分析-NonFair-tryAcquire"><a href="#tryAcquire方法源码分析-NonFair-tryAcquire" class="headerlink" title="tryAcquire方法源码分析(NonFair#tryAcquire)"></a>tryAcquire方法源码分析(NonFair#tryAcquire)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="nonfairTryAcquire方法源码分析-NonFair-nonfairTryAcquire"><a href="#nonfairTryAcquire方法源码分析-NonFair-nonfairTryAcquire" class="headerlink" title="nonfairTryAcquire方法源码分析(NonFair#nonfairTryAcquire)"></a>nonfairTryAcquire方法源码分析(NonFair#nonfairTryAcquire)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比公平锁和非公平锁的tryAcquire方法就知道非公平锁少了一个判断自己要不要排队，因为他是非公平可以直接CAS操作，而不用去判断。</p>
<h4 id="hasQueuedPredecessors-判断是否需要排队的源码分析"><a href="#hasQueuedPredecessors-判断是否需要排队的源码分析" class="headerlink" title="hasQueuedPredecessors  判断是否需要排队的源码分析"></a>hasQueuedPredecessors  判断是否需要排队的源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面提到的所有不需要排队，并不是字面意义，我实在想不出什么词语来描述这个“不需要排队”；不需要排队有两种情况</span></span><br><span class="line"><span class="comment">     * 一：队列没有初始化，不需要排队，不需要排队，不需要排队；直接去加锁，但是可能会失败；为什么会失败呢？</span></span><br><span class="line"><span class="comment">     * 假设两个线程同时来lock，都看到队列没有初始化，都认为不需要排队，都去进行CAS修改计数器；有一个必然失败</span></span><br><span class="line"><span class="comment">     * 比如t1先拿到锁，那么另外一个t2则会CAS失败，这个时候t2就会去初始化队列，并排队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 二：队列被初始化了，但是tc过来加锁，发觉队列当中第一个排队的就是自己；比如重入；</span></span><br><span class="line"><span class="comment">     * 那么什么叫做第一个排队的呢？下面解释了，很重要往下看；</span></span><br><span class="line"><span class="comment">     * 这个时候他也不需要排队，不需要排队，不需要排队；为什么不需要排对？</span></span><br><span class="line"><span class="comment">     * 因为队列当中第一个排队的线程他会去尝试获取一下锁，因为有可能这个时候持有锁锁的那个线程可能释放了锁；</span></span><br><span class="line"><span class="comment">     * 如果释放了就直接获取锁执行。但是如果没有释放他就会去排队，</span></span><br><span class="line"><span class="comment">     * 所以这里的不需要排队，不是真的不需要排队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * h != t 判断首不等于尾这里要分三种情况</span></span><br><span class="line"><span class="comment">     * 1、队列没有初始化，也就是第一个线程tf来加锁的时候那么这个时候队列没有初始化，</span></span><br><span class="line"><span class="comment">     * h和t都是null，那么这个时候判断不等于则不成立（false）那么由于是&amp;&amp;运算后面的就不会走了，</span></span><br><span class="line"><span class="comment">     * 直接返回false表示不需要排队，而前面又是取反（if (!hasQueuedPredecessors()），所以会直接去cas加锁。</span></span><br><span class="line"><span class="comment">     * ----------第一种情况总结：队列没有初始化没人排队，那么我直接不排队，直接上锁；合情合理、有理有据令人信服；</span></span><br><span class="line"><span class="comment">     * 好比你去火车站买票，服务员都闲的蛋疼，整个队列都没有形成；没人排队，你直接过去交钱拿票</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2、队列被初始化了，后面会分析队列初始化的流程，如果队列被初始化那么h!=t则成立；（不绝对，还有第3中情况）</span></span><br><span class="line"><span class="comment">     * h != t 返回true；但是由于是&amp;&amp;运算，故而代码还需要进行后续的判断</span></span><br><span class="line"><span class="comment">     * （有人可能会疑问，比如队列初始化了；里面只有一个数据，那么头和尾都是同一个怎么会成立呢？</span></span><br><span class="line"><span class="comment">     * 其实这是第3种情况--对头等于对尾；但是这里先不考虑，我们假设现在队列里面有大于1个数据）</span></span><br><span class="line"><span class="comment">     * 大于1个数据则成立;继续判断把h.next赋值给s；s有是对头的下一个Node，</span></span><br><span class="line"><span class="comment">     * 这个时候s则表示他是队列当中参与排队的线程而且是排在最前面的；</span></span><br><span class="line"><span class="comment">     * 为什么是s最前面不是h嘛？诚然h是队列里面的第一个，但是不是排队的第一个；下文有详细解释</span></span><br><span class="line"><span class="comment">     * 因为h也就是对头对应的Node对象或者线程他是持有锁的，但是不参与排队；</span></span><br><span class="line"><span class="comment">     * 这个很好理解，比如你去买车票，你如果是第一个这个时候售票员已经在给你服务了，你不算排队，你后面的才算排队；</span></span><br><span class="line"><span class="comment">     * 队列里面的h是不参与排队的这点一定要明白；参考下面关于队列初始化的解释；</span></span><br><span class="line"><span class="comment">     * 因为h要么是虚拟出来的节点，要么是持有锁的节点；什么时候是虚拟的呢？什么时候是持有锁的节点呢？下文分析</span></span><br><span class="line"><span class="comment">     * 然后判断s是否等于空，其实就是判断队列里面是否只有一个数据；</span></span><br><span class="line"><span class="comment">     * 假设队列大于1个，那么肯定不成立（s==null----&gt;false），因为大于一个Node的时候h.next肯定不为空；</span></span><br><span class="line"><span class="comment">     * 由于是||运算如果返回false，还要判断s.thread != Thread.currentThread()；这里又分为两种情况</span></span><br><span class="line"><span class="comment">     *        2.1 s.thread != Thread.currentThread() 返回true，就是当前线程不等于在排队的第一个线程s；</span></span><br><span class="line"><span class="comment">     *              那么这个时候整体结果就是h!=t：true; （s==null false || s.thread != Thread.currentThread() true  最后true）</span></span><br><span class="line"><span class="comment">     *              结果： true &amp;&amp; true 方法最终放回true，所以需要去排队</span></span><br><span class="line"><span class="comment">     *              其实这样符合情理，试想一下买火车票，队列不为空，有人在排队；</span></span><br><span class="line"><span class="comment">     *              而且第一个排队的人和现在来参与竞争的人不是同一个，那么你就乖乖去排队</span></span><br><span class="line"><span class="comment">     *        2.2 s.thread != Thread.currentThread() 返回false 表示当前来参与竞争锁的线程和第一个排队的线程是同一个线程</span></span><br><span class="line"><span class="comment">     *             这个时候整体结果就是h!=t----&gt;true; （s==null false || s.thread != Thread.currentThread() false-----&gt; 最后false）</span></span><br><span class="line"><span class="comment">     *            结果：true &amp;&amp; false 方法最终放回false，所以不需要去排队</span></span><br><span class="line"><span class="comment">     *            不需要排队则调用 compareAndSetState(0, acquires) 去改变计数器尝试上锁；</span></span><br><span class="line"><span class="comment">     *            这里又分为两种情况（日了狗了这一行代码；有同学课后反应说子路老师老师老是说这个AQS难，</span></span><br><span class="line"><span class="comment">     *            你现在仔细看看这一行代码的意义，真的不简单的）</span></span><br><span class="line"><span class="comment">     *             2.2.1  第一种情况加锁成功？有人会问为什么会成功啊，如这个时候h也就是持有锁的那个线程执行完了</span></span><br><span class="line"><span class="comment">     *                      释放锁了，那么肯定成功啊；成功则执行 setExclusiveOwnerThread(current); 然后返回true 自己看代码</span></span><br><span class="line"><span class="comment">     *             2.2.2  第二种情况加锁失败？有人会问为什么会失败啊。假如这个时候h也就是持有锁的那个线程没执行完</span></span><br><span class="line"><span class="comment">     *                       没释放锁，那么肯定失败啊；失败则直接返回false，不会进else if（else if是相对于 if (c == 0)的）</span></span><br><span class="line"><span class="comment">     *                      那么如果失败怎么办呢？后面分析；</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *----------第二种情况总结，如果队列被初始化了，而且至少有一个人在排队那么自己也去排队；但是有个插曲；</span></span><br><span class="line"><span class="comment">     * ----------他会去看看那个第一个排队的人是不是自己，如果是自己那么他就去尝试加锁；尝试看看锁有没有释放</span></span><br><span class="line"><span class="comment">     *----------也合情合理，好比你去买票，如果有人排队，那么你乖乖排队，但是你会去看第一个排队的人是不是你女朋友；</span></span><br><span class="line"><span class="comment">     *----------如果是你女朋友就相当于是你自己（这里实在想不出现实世界关于重入的例子，只能用男女朋友来替代）；</span></span><br><span class="line"><span class="comment">     * --------- 你就叫你女朋友看看售票员有没有搞完，有没有轮到你女朋友，因为你女朋友是第一个排队的</span></span><br><span class="line"><span class="comment">     * 疑问：比如如果在在排队，那么他是park状态，如果是park状态，自己怎么还可能重入啊。</span></span><br><span class="line"><span class="comment">     * 希望有同学可以想出来为什么和我讨论一下，作为一个菜逼，希望有人教教我</span></span><br><span class="line"><span class="comment">     *  </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 3、队列被初始化了，但是里面只有一个数据；什么情况下才会出现这种情况呢？ts加锁的时候里面就只有一个数据？</span></span><br><span class="line"><span class="comment">     * 其实不是，因为队列初始化的时候会虚拟一个h作为头结点，tc=ts作为第一个排队的节点；tf为持有锁的节点</span></span><br><span class="line"><span class="comment">     * 为什么这么做呢？因为AQS认为h永远是不排队的，假设你不虚拟节点出来那么ts就是h，</span></span><br><span class="line"><span class="comment">     *  而ts其实需要排队的，因为这个时候tf可能没有执行完，还持有着锁，ts得不到锁，故而他需要排队；</span></span><br><span class="line"><span class="comment">     * 那么为什么要虚拟为什么ts不直接排在tf之后呢，上面已经时说明白了，tf来上锁的时候队列都没有，他不进队列，</span></span><br><span class="line"><span class="comment">     * 故而ts无法排在tf之后，只能虚拟一个thread=null的节点出来（Node对象当中的thread为null）；</span></span><br><span class="line"><span class="comment">     * 那么问题来了；究竟什么时候会出现队列当中只有一个数据呢？假设原队列里面有5个人在排队，当前面4个都执行完了</span></span><br><span class="line"><span class="comment">     * 轮到第五个线程得到锁的时候；他会把自己设置成为头部，而尾部又没有，故而队列当中只有一个h就是第五个</span></span><br><span class="line"><span class="comment">     * 至于为什么需要把自己设置成头部；其实已经解释了，因为这个时候五个线程已经不排队了，他拿到锁了；</span></span><br><span class="line"><span class="comment">     * 所以他不参与排队，故而需要设置成为h；即头部；所以这个时间内，队列当中只有一个节点</span></span><br><span class="line"><span class="comment">     * 关于加锁成功后把自己设置成为头部的源码，后面会解析到；继续第三种情况的代码分析</span></span><br><span class="line"><span class="comment">     * 记得这个时候队列已经初始化了，但是只有一个数据，并且这个数据所代表的线程是持有锁</span></span><br><span class="line"><span class="comment">     * h != t false 由于后面是&amp;&amp;运算，故而返回false可以不参与运算，整个方法返回false；不需要排队</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *-------------第三种情况总结：如果队列当中只有一个节点，而这种情况我们分析了，</span></span><br><span class="line"><span class="comment">     *-------------这个节点就是当前持有锁的那个节点，故而我不需要排队，进行cas；尝试加锁</span></span><br><span class="line"><span class="comment">     *-------------这是AQS的设计原理，他会判断你入队之前，队列里面有没有人排队；</span></span><br><span class="line"><span class="comment">     *-------------有没有人排队分两种情况；队列没有初始化，不需要排队</span></span><br><span class="line"><span class="comment">     *--------------队列初始化了，按时只有一个节点，也是没人排队，自己先也不排队</span></span><br><span class="line"><span class="comment">     *--------------只要认定自己不需要排队，则先尝试加锁；加锁失败之后再排队；</span></span><br><span class="line"><span class="comment">     *--------------再一次解释了不需要排队这个词的歧义性</span></span><br><span class="line"><span class="comment">     *-------------如果加锁失败了，在去park，下文有详细解释这样设计源码和原因</span></span><br><span class="line"><span class="comment">     *-------------如果持有锁的线程释放了锁，那么我能成功上锁</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="acquireQueued-addWaiter-Node-exclusive-arg-方法解析"><a href="#acquireQueued-addWaiter-Node-exclusive-arg-方法解析" class="headerlink" title="acquireQueued(addWaiter(Node.exclusive),arg))方法解析"></a>acquireQueued(addWaiter(Node.exclusive),arg))方法解析</h4><p>如果代码能执行到这里说tc需要排队<br>需要排队有两种情况—换言之代码能够执行到这里有两种情况：<br>1、tf持有了锁，并没有释放，所以tc来加锁的时候需要排队，但这个时候—队列并没有初始化<br>2、tn(无所谓哪个线程，反正就是一个线程)持有了锁，那么由于加锁tn!=tf(tf是属于第一种情况，我们现在不考虑tf了)，所以队列是一定被初始化了的，tc来加锁，那么队列当中有人在排队，故而他也去排队</p>
<h4 id="addWaiter-Node-EXCLUSIVE-源码分析"><a href="#addWaiter-Node-EXCLUSIVE-源码分析" class="headerlink" title="addWaiter(Node.EXCLUSIVE)源码分析"></a>addWaiter(Node.EXCLUSIVE)源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//由于AQS队列当中的元素类型为Node，故而需要把当前线程tc封装成为一个Node对象,下文我们叫做nc</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">//tail为对尾，赋值给pred </span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">//判断pred是否为空，其实就是判断对尾是否有节点，其实只要队列被初始化了对尾肯定不为空，</span></span><br><span class="line">    <span class="comment">//假设队列里面只有一个元素，那么对尾和对首都是这个元素</span></span><br><span class="line">    <span class="comment">//换言之就是判断队列有没有初始化</span></span><br><span class="line">    <span class="comment">//上面我们说过代码执行到这里有两种情况，1、队列没有初始化和2、队列已经初始化了</span></span><br><span class="line">    <span class="comment">//pred不等于空表示第二种情况，队列被初始化了，如果是第二种情况那比较简单</span></span><br><span class="line">   <span class="comment">//直接把当前线程封装的nc的上一个节点设置成为pred即原来的对尾</span></span><br><span class="line">   <span class="comment">//继而把pred的下一个节点设置为当nc，这个nc自己成为对尾了</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//直接把当前线程封装的nc的上一个节点设置成为pred即原来的对尾，对应 10行的注释</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//这里需要cas，因为防止多个线程加锁，确保nc入队的时候是原子操作</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">//继而把pred的下一个节点设置为当nc，这个nc自己成为对尾了 对应第11行注释</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="comment">//然后把nc返回出去，方法结束</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果上面的if不成了就会执行到这里，表示第一种情况队列并没有初始化---下面解析这个方法</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="comment">//返回nc</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;<span class="comment">//这里的node就是当前线程封装的node也就是nc</span></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//对尾复制给t，上面已经说过队列没有初始化，</span></span><br><span class="line">        <span class="comment">//故而第一次循环t==null（因为是死循环，因此强调第一次，后面可能还有第二次、第三次，每次t的情况肯定不同）</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//第一次循环成了成立</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">//new Node就是实例化一个Node对象下文我们称为nn，</span></span><br><span class="line">            <span class="comment">//调用无参构造方法实例化出来的Node里面三个属性都为null，可以关联Node类的结构，</span></span><br><span class="line">            <span class="comment">//compareAndSetHead入队操作；把这个nn设置成为队列当中的头部，cas防止多线程、确保原子操作；</span></span><br><span class="line">            <span class="comment">//记住这个时候队列当中只有一个，即nn</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">//这个时候AQS队列当中只有一个元素，即头部=nn，所以为了确保队列的完整，设置头部等于尾部，即nn即是头也是尾</span></span><br><span class="line">                <span class="comment">//然后第一次循环结束；接着执行第二次循环，第二次循环代码我写在了下面，接着往下看就行</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便 第二次循环我再贴一次代码来对第二遍循环解释</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;<span class="comment">//这里的node就是当前线程封装的node也就是nc</span></span><br><span class="line">    <span class="comment">//死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//对尾复制给t，由于第二次循环，故而tail==nn，即new出来的那个node</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">//第二次循环不成立</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不成立故而进入else</span></span><br><span class="line">            <span class="comment">//首先把nc，当前线程所代表的的node的上一个节点改变为nn，因为这个时候nc需要入队，入队的时候需要把关系维护好</span></span><br><span class="line">            <span class="comment">//所谓的维护关系就是形成链表，nc的上一个节点只能为nn，这个很好理解</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//入队操作--把nc设置为对尾，对首是nn，</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                <span class="comment">//上面我们说了为了维护关系把nc的上一个节点设置为nn</span></span><br><span class="line">                <span class="comment">//这里同样为了维护关系，把nn的下一个节点设置为nc</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="comment">//然后返回t，即nn，死循环结束，enq(node);方法返回</span></span><br><span class="line">                <span class="comment">//这个返回其实就是为了终止循环，返回出去的t，没有意义</span></span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这个方法已经解释完成了</span></span><br><span class="line">  enq(node);</span><br><span class="line">  <span class="comment">//返回nc，不管哪种情况都会返回nc；到此addWaiter方法解释完成</span></span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//再次贴出node的结构方便大家查看</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-------------------总结：addWaiter方法就是让nc入队-并且维护队列的链表关系，但是由于情况复杂做了不同处理</span><br><span class="line">-------------------主要针对队列是否有初始化，没有初始化则<span class="keyword">new</span>一个新的Node nn作为对首，nn里面的线程为<span class="keyword">null</span></span><br><span class="line">-------------------接下来分析acquireQueued方法</span><br></pre></td></tr></table></figure>

<p>acquireQueued(addWaiter(Node.exclusive),arg))经过上面的解析之后可以理解成为acquireQueued(nc,arg)) </p>
<h4 id="acquireQueued方法的源码分析"><a href="#acquireQueued方法的源码分析" class="headerlink" title="acquireQueued方法的源码分析"></a>acquireQueued方法的源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;<span class="comment">//这里的node 就是当前线程封装的那个node 下文叫做nc</span></span><br><span class="line">    <span class="comment">//记住标志很重要</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//同样是一个标志</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取nc的上一个节点，有两种情况；1、上一个节点为头部；2上一个节点不为头部</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果nc的上一个节点为头部，则表示nc为队列当中的第二个元素，为队列当中的第一个排队的Node；</span></span><br><span class="line">            <span class="comment">//这里的第一和第二不冲突；我上文有解释；</span></span><br><span class="line">            <span class="comment">//如果nc为队列当中的第二个元素，第一个排队的则调用tryAcquire去尝试加锁---关于tryAcquire看上面的分析</span></span><br><span class="line">            <span class="comment">//只有nc为第二个元素；第一个排队的情况下才会尝试加锁，其他情况直接去park了，</span></span><br><span class="line">            <span class="comment">//因为第一个排队的执行到这里的时候需要看看持有有锁的线程有没有释放锁，释放了就轮到我了，就不park了</span></span><br><span class="line">            <span class="comment">//有人会疑惑说开始调用tryAcquire加锁失败了（需要排队），这里为什么还要进行tryAcquire不是重复了吗？</span></span><br><span class="line">            <span class="comment">//其实不然，因为第一次tryAcquire判断是否需要排队，如果需要排队，那么我就入队；</span></span><br><span class="line">            <span class="comment">//当我入队之后我发觉前面那个人就是第一个，持有锁的那个，那么我不死心，再次问问前面那个人搞完没有</span></span><br><span class="line">            <span class="comment">//如果他搞完了，我就不park，接着他搞我自己的事；如果他没有搞完，那么我则在队列当中去park，等待别人叫我</span></span><br><span class="line">            <span class="comment">//但是如果我去排队，发觉前面那个人在睡觉，前面那个人都在睡觉，那么我也睡觉把---------------好好理解一下</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//能够执行到这里表示我来加锁的时候，锁被持有了，我去排队，进到队列当中的时候发觉我前面那个人没有park，</span></span><br><span class="line">                <span class="comment">//前面那个人就是当前持有锁的那个人，那么我问问他搞完没有</span></span><br><span class="line">                <span class="comment">//能够进到这个里面就表示前面那个人搞完了；所以这里能执行到的几率比较小；但是在高并发的世界中这种情况真的需要考虑</span></span><br><span class="line">                <span class="comment">//如果我前面那个人搞完了，我nc得到锁了，那么前面那个人直接出队列，我自己则是对首；这行代码就是设置自己为对首</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">//这里的P代表的就是刚刚搞完事的那个人，由于他的事情搞完了，要出队；怎么出队？把链表关系删除</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                <span class="comment">//设置表示---记住记加锁成功的时候为false</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//返回false；为什么返回false？下次博客解释---比较复杂和加锁无关</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进到这里分为两种情况</span></span><br><span class="line">            <span class="comment">//1、nc的上一个节点不是头部，说白了，就是我去排队了，但是我上一个人不是队列第一个</span></span><br><span class="line">            <span class="comment">//2、第二种情况，我去排队了，发觉上一个节点是第一个，但是他还在搞事没有释放锁</span></span><br><span class="line">            <span class="comment">//不管哪种情况这个时候我都需要park，park之前我需要把上一个节点的状态改成park状态</span></span><br><span class="line">            <span class="comment">//这里比较难以理解为什么我需要去改变上一个节点的park状态呢？每个node都有一个状态，默认为0，表示无状态</span></span><br><span class="line">            <span class="comment">//-1表示在park；当时不能自己把自己改成-1状态？为什么呢？因为你得确定你自己park了才是能改为-1；</span></span><br><span class="line">            <span class="comment">//不然你自己改成自己为-1；但是改完之后你没有park那不就骗人？</span></span><br><span class="line">            <span class="comment">//你对外宣布自己是单身状态，但是实际和刘宏斌私下约会；这有点坑人</span></span><br><span class="line">            <span class="comment">//所以只能先park；在改状态；但是问题你自己都park了；完全释放CPU资源了，故而没有办法执行任何代码了，</span></span><br><span class="line">            <span class="comment">//所以只能别人来改；故而可以看到每次都是自己的后一个节点把自己改成-1状态</span></span><br><span class="line">            <span class="comment">//关于shouldParkAfterFailedAcquire这个方法的源码下次博客继续讲吧</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">//改上一个节点的状态成功之后；自己park；到此加锁过程说完了</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="shouldParkAfterFailedAcquire源码分析"><a href="#shouldParkAfterFailedAcquire源码分析" class="headerlink" title="shouldParkAfterFailedAcquire源码分析"></a>shouldParkAfterFailedAcquire源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">waitStatus代表节点的状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果前一个节点的状态是<em>SIGNAL</em>，则需要park；</p>
</li>
<li><p>如果<code>ws &gt; 0</code>，表示已被取消，删除状态是已取消的节点；</p>
</li>
<li><p>其他情况，设置前继节点的状态为<em>SIGNAL</em>。</p>
<p>可见，只有在前继节点的状态是<em>SIGNAL</em>时，需要park。 </p>
</li>
</ul>
<h4 id="parkAndCheckInterrupt源码分析"><a href="#parkAndCheckInterrupt源码分析" class="headerlink" title="parkAndCheckInterrupt源码分析"></a>parkAndCheckInterrupt源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞当前线程，然后返回线程的中断状态并复位中断状态。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>为什么要判断中断状态？</strong></p>
<p>首先要知道，acquireQueued方法中获取锁的方式是死循环，判断是否中断是在parkAndCheckInterrupt方法中实现的。</p>
<blockquote>
<p>注意interrupted()方法的作用，该方法是获取线程的中断状态，并复位，也就是说，如果当前线程是中断状态，则第一次调用该方法获取的是<code>true</code>，第二次则是<code>false</code>。而isInterrupted()方法则只是返回线程的中断状态，不执行复位操作。</p>
</blockquote>
<p>如果acquireQueued执行完毕，返回中断状态，回到acquire方法中，根据返回的中断状态判断是否需要执行<code>Thread.currentThread().interrupt()</code>。</p>
<p>为什么要多做这一步呢？先判断中断状态，然后复位，如果之前线程是中断状态，再进行中断？</p>
<p>这里就要介绍一下park方法了。park方法是Unsafe类中的方法，与之对应的是unpark方法。简单来说，当前线程如果执行了park方法，也就是阻塞了当前线程，反之，unpark就是唤醒一个线程。</p>
<p>park与wait的作用类似，但是对中断状态的处理并不相同。如果当前线程不是中断的状态，park与wait的效果是一样的；如果一个线程是中断的状态，这时执行wait方法会报<code>java.lang.IllegalMonitorStateException</code>，而执行park时并不会报异常，而是直接返回。</p>
<p>所以，知道了这一点，就可以知道为什么要进行中断状态的复位了：</p>
<ul>
<li>如果当前线程是非中断状态，则在执行park时被阻塞，这是返回中断状态是<code>false</code>；</li>
<li>如果当前线程是中断状态，则park方法不起作用，会立即返回，然后parkAndCheckInterrupt方法会获取中断的状态，也就是<code>true</code>，并复位；</li>
<li>再次执行循环的时候，由于在前一步已经把该线程的中断状态进行了复位，则再次调用park方法时会阻塞。</li>
</ul>
<p>所以，这里判断线程中断的状态实际上是为了不让循环一直执行，要让当前线程进入阻塞的状态。想象一下，如果不这样判断，前一个线程在获取锁之后执行了很耗时的操作，那么岂不是要一直执行该死循环？这样就造成了CPU使用率飙升，这是很严重的后果。</p>
<h4 id="cancelAcquire源码分析"><a href="#cancelAcquire源码分析" class="headerlink" title="cancelAcquire源码分析"></a>cancelAcquire源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置该节点不再关联任何线程</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    <span class="comment">// 通过前继节点跳过取消状态的node</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    <span class="comment">// 获取过滤后的前继节点的后继节点</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置状态为取消状态</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">     * If we are the tail, remove ourselves.</span></span><br><span class="line"><span class="comment">     * 1.如果当前节点是tail：</span></span><br><span class="line"><span class="comment">     * 尝试更新tail节点，设置tail为pred；</span></span><br><span class="line"><span class="comment">     * 更新失败则返回，成功则设置tail的后继节点为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">         <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 2.如果当前节点不是head的后继节点：</span></span><br><span class="line"><span class="comment">         * 判断当前节点的前继节点的状态是否是SIGNAL，如果不是则尝试设置前继节点的状态为SIGNAL；</span></span><br><span class="line"><span class="comment">         * 上面两个条件如果有一个返回true，则再判断前继节点的thread是否不为空；</span></span><br><span class="line"><span class="comment">         * 若满足以上条件，则尝试设置当前节点的前继节点的后继节点为当前节点的后继节点，也就是相当于			 * 将当前节点从队列中删除</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 3.如果是head的后继节点或者状态判断或设置失败，则唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中执行的过程有些复杂，首先是要获取当前节点的前继节点，如果前继节点的状态不是取消状态（即<code>pred.waitStatus &gt; 0</code>），则向前遍历队列，直到遇到第一个<code>waitStatus &lt;= 0</code>的节点，并把当前节点的前继节点设置为该节点，然后设置当前节点的状态为取消状态。</p>
<p>接下来的工作可以分为3种情况：</p>
<ul>
<li>当前节点是tail；</li>
<li>当前节点不是head的后继节点（即队列的第一个节点，不包括head），也不是tail；</li>
<li>当前节点是head的后继节点。</li>
</ul>
<p>我们依次来分析一下：</p>
<p><strong>当前节点是tail</strong></p>
<p>这种情况很简单，因为tail是队列的最后一个节点，如果该节点需要取消，则直接把该节点的前继节点的next指向null，也就是把当前节点移除队列。出队的过程如下：</p>
<p><img src="/2021/05/13/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/cancelCondition1.png" alt="tail"></p>
<p>注意：经验证，这里并没有设置node的prev为null。 </p>
<p><strong>当前节点不是head的后继节点，也不是tail</strong> </p>
<p><img src="/2021/05/13/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/cancelCondition2.png" alt="center"></p>
<p>这里将node的前继节点的next指向了node的后继节点，真正执行的代码就是如下一行：</p>
<p><code>compareAndSetNext(pred, predNext, next);</code></p>
<p><strong>当前节点是head的后继节点</strong></p>
<p><img src="/2021/05/13/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/cancelCondition3.png" alt="head"></p>
<p>这里直接unpark后继节点的线程，然后将next指向了自己。</p>
<p>这里可能会有疑问，既然要删除节点，为什么都没有对prev进行操作，而仅仅是修改了next？</p>
<p>要明确的一点是，这里修改指针的操作都是CAS操作，在AQS中所有以<code>compareAndSet</code>开头的方法都是尝试更新，并不保证成功，图中所示的都是执行成功的情况。</p>
<p>那么在执行cancelAcquire方法时，当前节点的前继节点有可能已经执行完并移除队列了（参见<code>setHead</code>方法），所以在这里只能用CAS来尝试更新，而就算是尝试更新，也只能更新next，不能更新prev，因为prev是不确定的，否则有可能会导致整个队列的不完整，例如把prev指向一个已经移除队列的node。</p>
<p>什么时候修改prev呢？其实prev是由其他线程来修改的。回去看下shouldParkAfterFailedAcquire方法，该方法有这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br></pre></td></tr></table></figure>

<p>该段代码的作用就是通过prev遍历到第一个不是取消状态的node，并修改prev。</p>
<p>这里为什么可以更新prev？因为shouldParkAfterFailedAcquire方法是在获取锁失败的情况下才能执行，因此进入该方法时，说明已经有线程获得锁了，并且在执行该方法时，当前节点之前的节点不会变化（因为只有当下一个节点获得锁的时候才会设置head），所以这里可以更新prev，而且不必用CAS来更新。</p>
<h4 id="unparkSuccessor源码分析"><a href="#unparkSuccessor源码分析" class="headerlink" title="unparkSuccessor源码分析"></a>unparkSuccessor源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>加锁过程总结</strong>：<br>如果是第一个线程tf，那么和队列无关，线程直接持有锁。并且也不会初始化队列，如果接下来的线程都是交替执行，那么永远和AQS队列无关，都是直接线程持有锁，如果发生了竞争，比如tf持有锁的过程中T2来lock，那么这个时候就会初始化AQS，初始化AQS的时候会在队列的头部虚拟一个Thread为NULL的Node，因为队列当中的head永远是持有锁的那个node（除了第一次会虚拟一个，其他时候都是持有锁的那个线程锁封装的node），现在第一次的时候持有锁的是tf而tf不在队列当中所以虚拟了一个node节点，队列当中的除了head之外的所有的node都在park，当tf释放锁之后unpark某个（基本是队列当中的第二个，为什么是第二个呢？前面说过head永远是持有锁的那个node，当有时候也不会是第二个，比如第二个被cancel之后，至于为什么会被cancel，不在我们讨论范围之内，cancel的条件很苛刻，基本不会发生）node之后，node被唤醒，假设node是t2，那么这个时候会首先把t2变成head（sethead），在sethead方法里面会把t2代表的node设置为head，并且把node的Thread设置为null，为什么需要设置null？其实原因很简单，现在t2已经拿到锁了，node就不要排队了，那么node对Thread的引用就没有意义了。所以队列的head里面的Thread永远为null。</p>
<h4 id="AQS释放独占锁的实现"><a href="#AQS释放独占锁的实现" class="headerlink" title="AQS释放独占锁的实现"></a>AQS释放独占锁的实现</h4><p>释放通过unlock方法来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法调用了release方法，release是在AQS中定义的，看下release代码： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功后unpark后继节点的线程</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里首先尝试着去释放锁，成功了之后要去唤醒后继节点的线程，这样其他的线程才有机会去执行。</p>
<p>tryRelease代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是和tryAcquire方法类似？该方法也需要被重写，在Sync类中的代码如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是将锁的数量减1</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，</span></span><br><span class="line">    <span class="comment">// 直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录锁的数量</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前线程被释放之后，需要唤醒下一个节点的线程，通过unparkSuccessor方法来实现： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要功能就是要唤醒下一个线程，这里<code>s == null || s.waitStatus &gt; 0</code>判断后继节点是否为空或者是否是取消状态，然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点，至于为什么从尾部开始向前遍历，回想一下cancelAcquire方法的处理过程，cancelAcquire只是设置了next的变化，没有设置prev的变化，在最后有这样一行代码：<code>node.next = node</code>，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的。</p>
<p>到这里，通过ReentrantLock的lock和unlock分析已经基本完成了.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从ReentrantLock出发，比较完整的分析了AQS内部独占锁的实现，总体来说实现的思路很清晰，就是使用了标志位+队列的方式来处理锁的状态，包括锁的获取，锁的竞争以及锁的释放。在AQS中，state可以表示锁的数量，也可以表示其他状态，state的含义由子类去定义，自己只是提供了对state的维护。AQS通过state来实现线程对资源的访问控制，而state具体的含义要在子类中定义。</p>
<p>AQS在队列的维护上的实现比较复杂，尤其是节点取消时队列的维护，这里并不是通过一个线程来完成的。同时，AQS中大量的使用CAS来实现更新，这种更新能够保证状态和队列的完整性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wolflike.github.io/2021/05/13/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%9B%BE%E7%81%B5.jpg">
      <meta itemprop="name" content="鸿曦">
      <meta itemprop="description" content="没有什么知识是学不会的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wolflike">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/13/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/" class="post-title-link" itemprop="url">synchronized关键字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-13 12:09:57" itemprop="dateCreated datePublished" datetime="2021-05-13T12:09:57+08:00">2021-05-13</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-synchronized是什么"><a href="#1-synchronized是什么" class="headerlink" title="1.synchronized是什么"></a>1.synchronized是什么</h3><p>​    synchronized关键字是sun公司为了解决线程同步问题而开发出来的。当线程来访问synchronized所包括的代码块时，要隐式获取锁，而后来的线程需要被阻塞。在jdk1.6之前，synchronized一直是以重量锁出现。所谓的重量锁是不管线程间对共享区是交替访问还是竞争访问，线程都是首先获取锁。而获取锁的行为就是调用操作系统函数的过程，在高并发的情况下，频繁调用操作系统函数，严重损耗性能。所以在<em>Doug Lea</em>大师写完优秀的并发编程包后，sun公司优化了synchronized关键字。在jdk1.6之后，synchronized有了无锁、偏向锁、轻量锁和重量锁的概念。</p>
<h3 id="2-为什么要引入锁的多个状态"><a href="#2-为什么要引入锁的多个状态" class="headerlink" title="2.为什么要引入锁的多个状态"></a>2.为什么要引入锁的多个状态</h3><p>​    首次访问synchronized块的线程首先必须获取锁，然后才能执行synchronized块，而获取锁这个过程需要调用操作系统函数，这会导致cpu由用户态转变到内核态，而这个转变过程是很耗时间的。因此，可知获取synchronized锁的代价高。其次如果存在线程1还在访问synchronized块，而线程2此时也来访问synchronized块，这会导致线程之间存在竞争情况，这时synchronized会把线程2阻塞，而阻塞过程也是一个系统调用过程，这又会消耗不少时间。当然如果在高并发应用的情境中，时刻发生着线程之间的竞争，那么把synchronized直接设计为重量锁是没问题的。但是大部分情况下，线程之间是交替访问共享资源的。那么由此就可以产生一种设计思想：尽量不让程序调用系统函数。所以sun公司就设计了synchronized的无锁、偏向锁、轻量锁、重量锁使程序尽量不调用系统函数。</p>
<h3 id="3-怎么实现synchronized关键字"><a href="#3-怎么实现synchronized关键字" class="headerlink" title="3.怎么实现synchronized关键字"></a>3.怎么实现synchronized关键字</h3><p>​    首先要明确synchronized使作用在对象上的，所以线程要获取所谓的锁就要向synchronized所代表的那个对象拿。我们都知道任何一个对象都可以当作锁，那我们是如何拿到“锁”的呢？其实对象都有三部分数据：对象头、对象属性以及对象补齐（一个对象所占的大小必须是8字节的倍数，所以有时候需要补充字节）。对象头就是用来实现synchronized锁的。</p>
<p><img src="/2021/05/13/synchronized%E5%85%B3%E9%94%AE%E5%AD%97/ObjectHeader.jpg" alt="对象头"></p>
<p>上图是对象头的结构，随着锁的状态的变化，对象头的内容也会发生变化。最开始的状态是无锁状态标志位为01，但此时无锁状态是有两种状态：无锁可偏向和无锁不可偏向。也即是说还有一位偏向标志位。也就是说，初始状态有两种情况，可以为无锁可偏向或者无锁不可偏向。如果开启虚拟机参数-XX:+UseBiasedLocking=true,那默认是无锁可偏向的也就是101，如果关闭参数不启用偏向锁那就是001，然后调用对象的hashcode函数后，前25位会保存哈希码，那么状态就会变为001，如果调用了hashcode函数，那么锁状态是不可能到可偏向锁状态的，而是直接升为轻量锁000的。如果没有调用hashcode函数且开启了偏向锁参数，区访问synchronized块时，会到偏向锁状态101的，如果没有开启，那直接升级为轻量锁000。到了轻量锁的时候，如果存在竞争情况，那么就到重量锁010状态。设计四个状态的锁，第一个无锁状态是没有调用系统函数的，当然线程也没有访问synchronized块。第二可偏向锁状态作用就是用前25位来保存当前访问synchronized块的线程id，显然也没有调用系统函数。当线程访问完synchronized块后，没有其他线程访问，而其再次访问了，又可以直接进入synchronized块。当当前线程访问完后，有其他线程正好也来访问了，那就需要升级为轻量锁了，这就是所谓的交替访问（偏向锁撤销和升级轻量锁是需要消耗时间的，所以如果线程竞争情况激烈时，可以不用考虑偏向锁这一状态了，直接禁用掉）。偏向锁的撤销相对于调用系统函数来说消耗的时间就太少了，毕竟是在用户态下完成的。当然轻量锁形成后，线程执行完后要解锁的时候会把轻量锁000—-&gt;001,变成不可偏向无锁状态，这很合理。当其他线程需要访问的时候，需要用CAS指令判断是否是不可偏向无锁状态，如果是就把锁状态保存在当前线程的栈中，然后前25位指向栈中的地址，重新把状态置为000，如果发生竞争，那就直接升级重量锁010了，重量锁就要用到系统函数了，当线程2到达synchronized块时，如果线程1还没走，那么状态直接设为重量锁010，然后把调用系统函数阻塞线程2.等线程1走了之后，线程2重新锁上，它的状态也是重量级别的，当线程2走了之后，释放锁的时候，又会把状态置为001不可偏向锁，也即是说下一个线程访问的时候，又可以是轻量锁了。</p>
<p>总结：无锁不需做任何事；偏向锁只需要判断状态和线程id号就可以了。当有别的线程访问synchronized块的时候，就需要撤销偏向锁这一状态了，也就是说mark word中再也不存在偏向锁的状态了。轻量锁加锁的时候只需要CAS修改mark word中前25位为指向栈中的指针，状态为改为000，解锁的时候把前25位置0，状态位改回001无锁不可偏向状态（但是永远不可能回到偏向锁了）。重量锁加锁的时候，把前25位置为指向互斥锁的指针，状态为改为010，解锁的时候，前25位置为0，状态改为001。</p>
<p>总的来说synchronized的改进就是线程在加锁的时候会判断synchronized块是否有线程访问，如果有，调用系统函数阻塞之，如果没有，直接用CAS指令来改一下mark word就可以了（CAS是cpu指令，不耗时间），但是没线程访问的时候，锁的状态还是无锁状态的。只是在上述基础上，加了偏向锁，也即是说，如果synchronized块始终只有一个线程访问的话，那就没必要老是用CAS指令来修改mark word，而是直接标记这个线程就可以了，下次来直接访问。当然偏向锁一旦撤销那是不可逆的。想想也很合理，如果偏向锁撤销了，说明有多个线程访问synchronized块，那偏向标志位就改为0了，因为当前线程不知道后面访问synchronized块的线程还是不是自己，所以不能改为1了，何况偏向锁的撤销也是挺费性能的，不能老是撤销偏向锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wolflike.github.io/2021/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%9B%BE%E7%81%B5.jpg">
      <meta itemprop="name" content="鸿曦">
      <meta itemprop="description" content="没有什么知识是学不会的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wolflike">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数据结构与算法总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-12 22:54:11" itemprop="dateCreated datePublished" datetime="2021-05-12T22:54:11+08:00">2021-05-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li><strong>拓扑排序</strong><ul>
<li> 求出所有节点的入度outEdges（数组）</li>
<li> 求出所有节点的邻接链表vertexAdjs（链表数组）</li>
<li> 把所有入度为0的节点进入队列</li>
<li> 最后按照进队出队规则完成拓扑</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopologicalSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以邻接链表为主</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    List&lt;Integer&gt;[] adj;</span><br><span class="line">    <span class="keyword">int</span>[] inDegree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        n = <span class="number">10005</span>;</span><br><span class="line">        adj = <span class="keyword">new</span> List[n];</span><br><span class="line"></span><br><span class="line">        inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">topologicalSort</span><span class="params">(List&lt;Integer&gt;[] adj,<span class="keyword">int</span>[] inDegree)</span></span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inDegree.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i]==<span class="number">0</span>)queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            Integer poll = queue.poll();</span><br><span class="line">            res.add(poll);</span><br><span class="line">            <span class="keyword">for</span>(Integer out:adj[poll])&#123;</span><br><span class="line">                <span class="keyword">if</span>(--inDegree[out]==<span class="number">0</span>)&#123;</span><br><span class="line">                    queue.add(out);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.size()==inDegree.length)<span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wolflike.github.io/2021/05/06/Hexo%E5%85%A5%E5%9D%91%EF%BC%88%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%9B%BE%E7%81%B5.jpg">
      <meta itemprop="name" content="鸿曦">
      <meta itemprop="description" content="没有什么知识是学不会的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wolflike">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/06/Hexo%E5%85%A5%E5%9D%91%EF%BC%88%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%89/" class="post-title-link" itemprop="url">Hexo入坑（安装与基本使用）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-06 00:51:51 / 修改时间：00:56:51" itemprop="dateCreated datePublished" datetime="2021-05-06T00:51:51+08:00">2021-05-06</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>主要介绍了Hexo与next主题的基本使用以及基本配置套路</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/06/Hexo%E5%85%A5%E5%9D%91%EF%BC%88%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%89/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wolflike.github.io/2021/05/05/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%9B%BE%E7%81%B5.jpg">
      <meta itemprop="name" content="鸿曦">
      <meta itemprop="description" content="没有什么知识是学不会的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wolflike">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-05 23:49:28" itemprop="dateCreated datePublished" datetime="2021-05-05T23:49:28+08:00">2021-05-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Hexo/" itemprop="url" rel="index"><span itemprop="name">Hexo</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/05/hello-world/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://wolflike.github.io/2021/05/05/%E5%85%AB%E8%82%A1%E6%96%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/%E5%9B%BE%E7%81%B5.jpg">
      <meta itemprop="name" content="鸿曦">
      <meta itemprop="description" content="没有什么知识是学不会的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wolflike">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/05/05/%E5%85%AB%E8%82%A1%E6%96%87/" class="post-title-link" itemprop="url">八股文-blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-05 21:08:17 / 修改时间：23:15:47" itemprop="dateCreated datePublished" datetime="2021-05-05T21:08:17+08:00">2021-05-05</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="八股文"><a href="#八股文" class="headerlink" title="八股文"></a>八股文</h3><hr>
<h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul>
<li>TCP<ul>
<li> 三次</li>
<li> 四次</li>
<li> 流量控制</li>
<li> 拥塞控制</li>
<li> 可靠传输</li>
</ul>
</li>
<li>IP<ul>
<li> 编址方式</li>
<li> 网络地址转换</li>
<li> 路由器分组转发</li>
</ul>
</li>
<li>Web页面得请求过程<ul>
<li> 获取动态IP、DNS ip、路由器ip（发MAC帧，通过交换机与DH交互）</li>
<li> ARP解析路由器MAC地址</li>
<li> 通过路由器从DNS那里获取域名IP</li>
<li> Http请求</li>
</ul>
</li>
<li>HTTP、HTTPS<ul>
<li> 长连接、短连接</li>
<li> 流水线</li>
<li> Cookie</li>
<li> Session</li>
</ul>
</li>
</ul>
<h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h4><ul>
<li>Socket<ul>
<li>I/O模型<ul>
<li> 阻塞i/o</li>
<li> 非阻塞i/o</li>
<li> i/o复用</li>
<li> 信号i/o</li>
<li> 异步i/o</li>
</ul>
</li>
<li>I/O复用应用<ul>
<li> select</li>
<li> poll</li>
<li> epoll</li>
</ul>
</li>
</ul>
</li>
<li>RPC<ul>
<li> 动态代理</li>
<li> 建立Socket连接</li>
</ul>
</li>
<li> 爬虫（分布式）队列、去重、请求、解析</li>
</ul>
<h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul>
<li> 进程、线程、协程</li>
<li> 进程通信</li>
<li>锁、死锁、同步<ul>
<li> 必要条件</li>
<li> 死锁检测</li>
<li> 死锁避免</li>
</ul>
</li>
<li> 虚拟内存（逻辑地址、线性地址、物理地址）、段页式、快表</li>
<li> 生产者消费者、读写锁</li>
<li>Linux（常规指令top）<ul>
<li> cat、grep、ps、Ctrl+C、Ctrl+D、man、info、who、pstree、top、netstat</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2021/05/05/%E5%85%AB%E8%82%A1%E6%96%87/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="鸿曦"
      src="/images/%E5%9B%BE%E7%81%B5.jpg">
  <p class="site-author-name" itemprop="name">鸿曦</p>
  <div class="site-description" itemprop="description">没有什么知识是学不会的</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">鸿曦</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
